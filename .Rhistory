extent(r1) <- extent(usa)
library(dplyr)
library(sf)
library(terra)
library(tmap)
library(raster)
r1 <- raster()
extent(r1) <- extent(usa)
#location data
d1 <- read.csv("data/cellsID.csv")
names(d1)<- c("lat","lon","ID.CELL","ID.BIOME")
usa <- d1 %>%
dplyr::filter(lat > 0)%>%
sf::st_as_sf(coords = c("lon","lat"))%>%
sf::st_set_crs(4326)
extent(r1) <- extent(usa)
r1
res(r1) <- 0.5
r1
library(dplyr)
ow <- read.csv("data/projectList.csv")
stateW <- read.csv("data/stateWells.csv")
names(ow)
View(ow)
View(stateW)
dim(ow)
dim(stateW)
library(sf)
library(tigris)
?counties
# attach county data to well locations ------------------------------------
county <- tigris::counties(state = "CO")
?st_as_sf
names(stateW)
# generate spatail data from well sites
w2 <- sf::st_as_sf(stateW, coords = c("Longitude", "Latitude"), 4326)
# generate spatail data from well sites
w2 <- sf::st_as_sf(stateW, coords = c("Longitude", "Latitude"),wkt = 4326)
# generate spatail data from well sites
w2 <- sf::st_as_sf(stateW, coords = c("Longitude", "Latitude"))
names(county)
c1 <- county %>%
dplyr::select("NAME")
library(tmap)
tmap::tmap_mode("view")
qtm(w2)
w2$county <- sf::st_intersection(w2,county)
crs(w2)
w2
# generate spatail data from well sites
w2 <- sf::st_as_sf(stateW, coords = c("Longitude", "Latitude"))%>%
sf::st_transform(crs = c1)
# generate spatail data from well sites
w2 <- sf::st_as_sf(stateW, coords = c("Longitude", "Latitude"))%>%
sf::st_transform(crs = sf::st_crs(c1))
# generate spatail data from well sites
w2 <- sf::st_as_sf(stateW, coords = c("Longitude", "Latitude"))%>%
sf::st_set_crs(value = 4326)%>%
sf::st_transform(crs = sf::st_crs(c1))
w2$county <- sf::st_intersection(w2,county)
View(w2)
# generate spatail data from well sites
w2 <- sf::st_as_sf(stateW, coords = c("Longitude", "Latitude"))%>%
sf::st_set_crs(value = 4326)%>%
sf::st_transform(crs = sf::st_crs(c1))
w2$county <- sf::st_intersection(w2,c1)
View(w2)
names(c1)
# generate spatail data from well sites
w2 <- sf::st_as_sf(stateW, coords = c("Longitude", "Latitude"))%>%
sf::st_set_crs(value = 4326)%>%
sf::st_transform(crs = sf::st_crs(c1))
names(w2)
w2$county <- sf::st_intersection(w2,c1)
names(w2)
head(w2)
names(w2
)
w2[1,
]
names(w2
)
# generate spatail data from well sites
w2 <- sf::st_as_sf(stateW, coords = c("Longitude", "Latitude"))%>%
sf::st_set_crs(value = 4326)%>%
sf::st_transform(crs = sf::st_crs(c1))%>%
dplyr::select(-description)
names(w2)
w2$county <- sf::st_intersection(w2,c1)
w2[1,]
View(w2)
w23 <- sf::st_intersection(w2,c1)
View(w23)
# generate spatail data from well sites
w2 <- sf::st_as_sf(stateW, coords = c("Longitude", "Latitude"))%>%
sf::st_set_crs(value = 4326)%>%
sf::st_transform(crs = sf::st_crs(c1))%>%
dplyr::select(-description)
w23 <- sf::st_intersection(w2,c1)
w2 <- sf::st_intersection(w2,c1)
# function to testing connections -----------------------------------------
test <- w2[1, ]
# filter on county
d1 <- ow[grepl(pattern = test$NAME, x = ow$County,ignore.case = TRUE),]
dim(d1)
View(d1)
test
names(d1)
# filter on project name
d2 <- dplyr::left_join(x = test, y = d1,
by = c("Project_Name"= "Project.Name"))
dim(d2)
i<- 1
matched <- d2
# function to testing connections -----------------------------------------
test <- w2[2, ]
# filter on county
d1 <- ow[grepl(pattern = test$NAME, x = ow$County,ignore.case = TRUE),]
# filter on project name
d2 <- dplyr::left_join(x = test, y = d1,
by = c("Project_Name"= "Project.Name"))
dim(d2)
dim(d1)
View(d1)
test
i <- 2
# filter on project name
d2 <- dplyr::left_join(x = test, y = d1,
by = c("Project_Name"= "Project.Name"))
# condition for exact match
if(nrow(d2)==1){
if(i == 1){
matched <- d2
}else{
matched <- dplyr::bind_rows(matched, d2)
}
}else{
}
matched
# function to testing connections -----------------------------------------
test <- w2[3, ]
# filter on county
d1 <- ow[grepl(pattern = test$NAME, x = ow$County,ignore.case = TRUE),]
# filter on project name
d2 <- dplyr::left_join(x = test, y = d1,
by = c("Project_Name"= "Project.Name"))
dim(d2)
# condition for exact match
if(nrow(d2)==1){
if(i == 1){
matched <- d2
}else{
matched <- dplyr::bind_rows(matched, d2)
}
}else{
}
# function to testing connections -----------------------------------------
test <- w2[4, ]
# filter on county
d1 <- ow[grepl(pattern = test$NAME, x = ow$County,ignore.case = TRUE),]
# filter on project name
d2 <- dplyr::left_join(x = test, y = d1,
by = c("Project_Name"= "Project.Name"))
# condition for exact match
if(nrow(d2)==1){
if(i == 1){
matched <- d2
}else{
matched <- dplyr::bind_rows(matched, d2)
}
}else{
}
d2
# function to testing connections -----------------------------------------
for(i in seq_along(w2$Name)){
test <- w2[i, ]
# filter on county
d1 <- ow[grepl(pattern = test$NAME, x = ow$County,ignore.case = TRUE),]
# filter on project name
d2 <- dplyr::left_join(x = test, y = d1,
by = c("Project_Name"= "Project.Name"))
# condition for exact match
if(nrow(d2)==1){
if(i == 1){
matched <- d2
}else{
matched <- dplyr::bind_rows(matched, d2)
}
}else{
print(i)
}
}
dim(w2)
dim(matched)
View(matched)
?st_as_sf
## fed data
fedW <- read.csv("data/federalWells.csv")
##comibne all wells
allWells <- bind_rows(stateW, fedW)
dim(allWells)
dim(fedW)
dim(stateW)
# generate spatail data from well sites
w2 <- sf::st_as_sf(allWells, coords = c("Longitude", "Latitude"),remove=FALSE)%>%
sf::st_set_crs(value = 4326)%>%
sf::st_transform(crs = sf::st_crs(c1))%>%
dplyr::select(-description)
sf::st_crs(c1)
dim(ow)
dim(allWells)
# generate spatail data from well sites
w2 <- sf::st_as_sf(allWells, coords = c("Longitude", "Latitude"),remove=FALSE)%>%
sf::st_set_crs(value = 4326)%>%
sf::st_transform(crs = sf::st_crs(c1))%>%
dplyr::select(-description)
w2 <- sf::st_intersection(w2,c1)
# function to testing connections -----------------------------------------
for(i in seq_along(w2$Name)){
test <- w2[i, ]
# filter on county
d1 <- ow[grepl(pattern = test$NAME, x = ow$County,ignore.case = TRUE),]
# filter on project name
d2 <- dplyr::left_join(x = test, y = d1,
by = c("Project_Name"= "Project.Name"))
# condition for exact match
if(nrow(d2)==1){
if(i == 1){
matched <- d2
}else{
matched <- dplyr::bind_rows(matched, d2)
}
}else{
print(i)
}
}
View(matched)
class(matched)
write.csv(x = matched%>%st_drop_geometry(),
file = "data/outputs/matchedWells/orphanedWells_LatLon.csv")
write.csv(x = matched%>%st_drop_geometry(),
file = "outputs/matchedWells/orphanedWells_LatLon.csv")
?write_sf
st_write(obj = matched, )
st_write(obj = matched,"outputs/matchedWells/orphanedWells.shp")
dim(matched)
library(sf)
library(dplyr)
d1 <- read.csv("data/cellsID.csv")
haed(d1)
head(d1)
library(readr)
d1 <- read_csv("data/cellsID.csv")%>%
st_as_sf(coords = c(""))
d1 <- read_csv("data/cellsID.csv")
names(d1)
d1 <- read_csv("data/cellsID.csv")%>%
st_as_sf(coords = c("LONGITUDE", "LATITUDE"))
class(d1)
bbox <- sf::st_bbox(d1)
bbox
head(d1)
View(d1)
?st_as_sf
d1 <- read_csv("data/cellsID.csv")%>%
st_as_sf(coords = c("LONGITUDE", "LATITUDE"),remove =FALSE)
head(d1)
us <- d1 %>%
dplyr::filter(LATITUDE > 0)
bbox <- sf::st_bbox(us)
bbox
# install.packages("pacman")
pacman::p_load(dplyr, readr, sf, terra, FedData)
# source scripts ----------------------------------------------------------
for(i in list.files(path = "src/dataProcessing" ,full.names = TRUE)){
source(i)
}
auGrid <- rast("data/ausGrid/OZgrids.tif")%>%
terra::project(auGPP)%>%
terra::as.polygons()
## aus
auGPP <- rast("data/earthEngineOutputs/gppAus.tif")
auGrid <- rast("data/ausGrid/OZgrids.tif")%>%
terra::project(auGPP)%>%
terra::as.polygons()
names(auGrid) <- "Id"
ausLC <- rast("L:/Projects_active/2021_ChevronConant_Oil_and_Gas/Data/ersi/OZ/GRID_NVIS4_1_AUST_MVG_EXT/aust4_1e_mvg/w001000.adf")
terra::plot(ausLC)
values <- c(2:32,99)
values
as.character(values)
# construct dataframe to hold all records
df <- data.frame(matrix(nrow = nrow(gridArea), ncol = 1+ length(values)))
landcover <- ausLC
gridArea <- auGrid
gridArea <- gridArea %>%
terra::project(landcover)
# just looking at the plot legend for list of all values
values <- c(2:32,99)
# construct dataframe to hold all records
df <- data.frame(matrix(nrow = nrow(gridArea), ncol = 1+ length(values)))
names(df) <- c("Id", as.character(values))
head(df)
gridArea
seq_along(gridArea$Id)
i <- 1
# select feature
t1 <- gridArea[i]
t1
# assgin Id
df$Id[i] <- t1$Id
# crop and mask image
r2 <- landcover %>% terra::crop(t1)%>%terra::mask(t1)
# determine values
vals <- values(r2)
vals
uniqueVals <- sort(unique(vals))
uniqueVals
total <- length(vals)
j <- 1
code <- as.numeric(values[j])
code
code %in% uniqueVals
for(j in seq_along(values)){
code <- as.numeric(values[j])
if(code %in% uniqueVals){
index <- code
val2 <- vals[vals == index, ]
sum1 <- length(val2)
percentCover <- (sum1/total)*100
df[i,as.character(index)] <- percentCover
}
}
head(df)
total
val2
index
head(df)
j <- 2
index <- code
val2 <- vals[vals == index, ]
val2
index
code <- as.numeric(values[j])
code
index <- code
val2 <- vals[vals == index, ]
val2
vals
index
vals[vals == 3, ]
vals[vals == 3]
# Nan features causing some issues
vals[is.nan(vals)] <- 9999
vals
val2 <- vals[vals == index, ]
val2
vals[is.na(vals)] <- 9991
uniqueVals <- sort(unique(vals))
unique(vals)
# determine values
vals <- values(r2)
uniqueVals <- sort(unique(vals))
# Nan features causing some issues
vals[is.nan(vals)] <- 9999
vals[is.na(vals)] <- 9991
total <- length(vals)
total
code <- as.numeric(values[j])
index <- code
val2 <- vals[vals == index, ]
unique(val2)
sum1 <- length(val2)
sum1
percentCover <- (sum1/total)*100
percentCover
# determine values
vals <- values(r2)
uniqueVals <- sort(unique(vals))
# Nan features causing some issues
vals[is.nan(vals)] <- 9999
vals[is.na(vals)] <- 9991
total <- length(vals)
for(j in seq_along(values)){
code <- as.numeric(values[j])
if(code %in% uniqueVals){
index <- code
val2 <- vals[vals == index, ]
sum1 <- length(val2)
percentCover <- (sum1/total)*100
df[i,as.character(index)] <- percentCover
}
}
HEAD(DF)
head(df)
for(i in seq_along(gridArea$Id)){
# select feature
t1 <- gridArea[i]
# assgin Id
df$Id[i] <- t1$Id
# crop and mask image
r2 <- landcover %>% terra::crop(t1)%>%terra::mask(t1)
# determine values
vals <- values(r2)
uniqueVals <- sort(unique(vals))
# Nan features causing some issues
vals[is.nan(vals)] <- 9999
vals[is.na(vals)] <- 9991
total <- length(vals)
for(j in seq_along(values)){
code <- as.numeric(values[j])
if(code %in% uniqueVals){
index <- code
val2 <- vals[vals == index, ]
sum1 <- length(val2)
percentCover <- (sum1/total)*100
df[i,as.character(index)] <- percentCover
}
}
# counter for progress
if(i %% 10 == 0){
print(paste0(i ," out of ", nrow(df)))
}
}
View(df)
# just looking at the plot legend for list of all values
values <- c(1:32,99)
# construct dataframe to hold all records
df <- data.frame(matrix(nrow = nrow(gridArea), ncol = 1+ length(values)))
names(df) <- c("Id", as.character(values))
for(i in seq_along(gridArea$Id)){
# select feature
t1 <- gridArea[i]
# assgin Id
df$Id[i] <- t1$Id
# crop and mask image
r2 <- landcover %>% terra::crop(t1)%>%terra::mask(t1)
# determine values
vals <- values(r2)
uniqueVals <- sort(unique(vals))
# Nan features causing some issues
vals[is.nan(vals)] <- 9999
vals[is.na(vals)] <- 9991
total <- length(vals)
for(j in seq_along(values)){
code <- as.numeric(values[j])
if(code %in% uniqueVals){
index <- code
val2 <- vals[vals == index, ]
sum1 <- length(val2)
percentCover <- (sum1/total)*100
df[i,as.character(index)] <- percentCover
}
}
# counter for progress
if(i %% 10 == 0){
print(paste0(i ," out of ", nrow(df)))
}
}
View(df)
# AUS land cover ----------------------------------------------------------
aus2015LC <- getAUS_LC(landcover = ausLC, gridArea = auGrid)
# install.packages("pacman")
pacman::p_load(dplyr, readr, sf, terra, FedData)
# source scripts ----------------------------------------------------------
for(i in list.files(path = "src/dataProcessing" ,full.names = TRUE)){
source(i)
}
## aus
auGPP <- rast("data/earthEngineOutputs/gppAus.tif")
auGrid <- rast("data/ausGrid/OZgrids.tif")%>%
terra::project(auGPP)%>%
terra::as.polygons()
names(auGrid) <- "Id"
# AUS land cover ----------------------------------------------------------
aus2015LC <- getAUS_LC(landcover = ausLC, gridArea = auGrid)
View(df)
View(aus2015LC)
# AUS land cover ----------------------------------------------------------
ausLC <- getAUS_LC(landcover = ausLC, gridArea = auGrid)
VieW(ausLC)
View(ausLC)
###
# primary workflow for all dataprocessing efforts
# carverd@colostate.edu
# 20211223
###
# install.packages("pacman")
pacman::p_load(dplyr, readr, sf, terra, FedData)
# source scripts ----------------------------------------------------------
for(i in list.files(path = "src/dataProcessing" ,full.names = TRUE)){
source(i)
}
# input datasets ----------------------------------------------------------
## usa
usGPP <- rast("data/earthEngineOutputs/gppUSA.tif")
usGrid <- vect("data/usGrid/US10km_reduced_grids.shp")
usLandCover <- rast("data/usLandCover/nlcd_2019_land_cover_l48_20210604.img") # this local file does not work.
usLandCover <- rast("L:/Projects_active/EnviroScreen/data/NLCD/Land Cover/nlcd_2019_land_cover_l48_20210604.img")
## aus
auGPP <- rast("data/earthEngineOutputs/gppAus.tif")
auGrid <- rast("data/ausGrid/OZgrids.tif")%>%
terra::project(auGPP)%>%
terra::as.polygons()
names(auGrid) <- "Id"
ausLC <- rast("L:/Projects_active/2021_ChevronConant_Oil_and_Gas/Data/ersi/OZ/GRID_NVIS4_1_AUST_MVG_EXT/aust4_1e_mvg/w001000.adf")
View(getAUS_LC)
# AUS land cover ----------------------------------------------------------
ausLC <- getAUS_LC(landcover = ausLC, gridArea = auGrid)
VieW(ausLC)
View(ausLC)
readr::write_csv(ausLC, file= paste0("outputs/ausLC",Sys.Date(),".csv"))
